<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Daily Expense Categorizer</title>
  <style>
    :root{
      --footer-h: 56px;

      --gap: 8px;
      --line: #dcdcdc;
    }
    *{box-sizing:border-box;}
    body{
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      margin: 0;
      padding: 12px 16px calc(var(--footer-h) + 24px + env(safe-area-inset-bottom));
      color:#111;
      background:#fff;
    }
    header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: var(--gap);
      margin-bottom: 8px;
      border-bottom:1px solid var(--line);
      padding-bottom:8px;
    }
    h1{
      font-size:20px;
      margin:0;
    }
    .meta{
      display:flex;
      gap:12px;
      align-items:center;
      flex-wrap:wrap;
      font-size:13px;
    }
    .pill{
      border:1px solid var(--line);
      border-radius:14px;
      padding:4px 10px;
      background:#f7f7f7;
    }
    table{
      width:100%;
      border-collapse:collapse;
      table-layout:auto;
      font-size:14px;
    }
    th, td{
      border:1px solid var(--line);
      padding:0.5rem;
      vertical-align:top;
      text-align:left;
    }
    th{
      background:#fafafa;
      font-weight:600;
    }
    tbody tr.categorized td.category{
      color:#0a7a0a;
      font-weight:600;
    }
    tfoot td{
      font-weight:600;
      background:#fafafa;
    }
    select, input[type="text"]{
      width:100%;
      padding:0.375rem 0.5rem;
      font:inherit;
      min-width:0;
    }
    .status{
      font-size:12px;
      opacity:.8;
    }
    .footer{padding-bottom: calc(10px + env(safe-area-inset-bottom));
      z-index: 1000;
      min-height: var(--footer-h);

      position: fixed;
      bottom:0;
      left:0;
      right:0;
      background:#fff;
      border-top:1px solid var(--line);
      padding:10px 12px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
    }
    .nav{
      display:flex;
      gap:6px;
      flex-wrap:wrap;
    }
    button{
      padding:6px 10px;
      border:1px solid #bbb;
      background:#f6f6f6;
      border-radius:8px;
      cursor:pointer;
      font:inherit;
    }
    button:disabled{
      opacity:.5;
      cursor:not-allowed;
    }
    .loading{
      text-align:center;
      padding:20px;
      color:#666;
    }
    .error{
      background:#fee;
      border:1px solid #c33;
      padding:12px;
      margin:12px 0;
      border-radius:4px;
      color:#c33;
    }
    .info{
      background:#eef6ff;
      border:1px solid #3b82f6;
      padding:12px;
      margin:12px 0;
      border-radius:4px;
      color:#1d4ed8;
    }
    @media (max-width: 768px) {
      table{
        font-size:12px;
      }
      th, td{
        padding:0.375rem 0.25rem;
      }
      th{
        font-size:11px;
      }
      select, input[type="text"]{
        padding:0.25rem 0.375rem;
        font-size:12px;
      }
      .meta{
        font-size:12px;
      }
      h1{
        font-size:18px;
      }
    }
    @media (max-width: 480px) {
      body{
        padding:8px 4px calc(var(--footer-h) + 16px + env(safe-area-inset-bottom));
      }
      table{
        font-size:11px;
      }
      th, td{
        padding:0.25rem;
      }
      select, input[type="text"]{
        padding:0.25rem;
        font-size:11px;
      }
      button{
        padding:4px 8px;
        font-size:12px;
      }
    }
    @media print{
      .footer{ display:none; }
      header{ border:none; }
    }
  </style>
</head>
<body>
  <!-- <div style="position: fixed; top: 0; left: 0; right: 0; background: red; color: white; padding: 20px; z-index: 99999; font-size: 24px;">
    PAGE IS LOADING - If you see this, HTML is working!
  </div> -->
  <header>
    <h1>Daily Expense Categorizer</h1>
    <div class="meta">
      <div class="pill" id="currentMonthPill">Month: <strong id="monthText"></strong></div>
      <div class="pill">Date: <strong id="dateText"></strong></div>
      <div class="pill">Uncategorized: <strong id="uncatCount">0</strong></div>
      <div class="pill">Total (day): <strong id="dayTotal">$0.00</strong></div>
    </div>
  </header>

  <receipt-scanner></receipt-scanner>

  <div id="loadingMsg" class="loading" style="background: yellow; color: red; font-size: 24px; padding: 40px; border: 5px solid red;">LOADING... If you see this for more than 2 seconds, check console for errors!</div>
  <div id="fallbackNotice" class="info" style="display:none;"></div>
  <div id="errorMsg" class="error" style="display:none;"></div>

  <table aria-label="Transactions for the day" style="display:none;" id="mainTable">
    <thead>
      <tr>
        <th style="min-width:10rem;">Vendor / Description</th>
        <th style="min-width:6rem;">Amount</th>
        <th style="min-width:12rem;">Category</th>
        <th style="min-width:10rem;">Notes</th>
        <th style="min-width:6rem;">Status</th>
      </tr>
    </thead>
    <tbody id="rows"></tbody>
    <tfoot>
      <tr>
        <td colspan="5">Showing transactions for <span id="dateTextBottom"></span></td>
      </tr>
    </tfoot>
  </table>

  <div class="footer">
    <div>
      <label for="monthSelect" style="font-size:13px;">Select month:</label>
      <select id="monthSelect" title="Select calendar month"></select>
    </div>
    <div class="nav">
      <button id="firstBtn" title="First day">&laquo; First</button>
      <button id="prevBtn" title="Previous day">&lsaquo; Previous</button>
      <button id="nextBtn" title="Next day">Next &rsaquo;</button>
      <button id="lastBtn" title="Last day">Last &raquo;</button>
    </div>
  </div>

<script type="module" src="/office/js/main.js" onerror="console.error('[DEBUG] Failed to load main.js module!')"></script>
<script type="module" src="/office/js/event-bus.js"></script>
<script type="module" src="/office/js/components/receipt-scanner.js"></script>
<script type="module">
  import { on } from '/office/js/event-bus.js';

  on('receipt:saved', async (data) => {
    console.log('Receipt saved event received:', data);
    // Optionally show a success message
    const infoDiv = document.getElementById('infoMsg') || document.createElement('div');
    infoDiv.id = 'infoMsg';
    infoDiv.className = 'info';
    infoDiv.textContent = `Receipt for ${data.expense_id} saved successfully!`;
    document.body.prepend(infoDiv);
    setTimeout(() => infoDiv.remove(), 5000); // Remove after 5 seconds

    await reloadTransactions(); // Reload transactions to show the new expense
  });

  on('receipt:error', (data) => {
    console.error('Receipt error event received:', data);
    const errorDiv = document.getElementById('errorMsg');
    errorDiv.textContent = `Error processing receipt: ${data.message}`;
    errorDiv.style.display = 'block';
  });
</script>
<script>
console.log('[DEBUG] Script starting execution...');
window.addEventListener('error', (e) => {
  console.error('[DEBUG] Global error:', e.error || e.message, e);
});
window.addEventListener('unhandledrejection', (e) => {
  console.error('[DEBUG] Unhandled promise rejection:', e.reason);
});
console.log('[DEBUG] Window location:', window.location.href);
console.log('[DEBUG] Window port:', window.location.port);

// ----- Configuration -----
// Auto-detect API base URL from current window location (works for localhost and WSL2 IP)
// Since API server is running on port 8080, point to it explicitly
const API_BASE = window.location.port === "8081"
  ? "http://localhost:8080/api"
  : `${window.location.protocol}//${window.location.host}/api`;
const STATIC_PORTS = new Set([]);  // Removed 8081 - use live API by default
const urlParams = new URLSearchParams(window.location.search);
const preferApi = urlParams.get("use_api") === "1" ||
  (!STATIC_PORTS.has(window.location.port) && urlParams.get("use_api") !== "0");

// ----- Global data -----
let allTransactions = [];
let categoryOptions = [];
let dataByDate = {};
let months = [];
let datesByMonth = {};

// ----- Utility helpers -----
const fmtCurrency = (n) => n.toLocaleString(undefined, {style:'currency', currency:'USD'});
const monthKey = (d) => d.slice(0,7); // 'YYYY-MM'
const monthLabel = (yyyyMM) => {
  const [y,m] = yyyyMM.split('-').map(Number);
  return new Date(y, m-1, 1).toLocaleString(undefined, {month:'long', year:'numeric'});
};

// ----- State -----
let state = {
  month: null,
  dayIdx: 0
};

// ----- DOM refs -----
const monthSelect = document.getElementById('monthSelect');
const rowsEl = document.getElementById('rows');
const dateText = document.getElementById('dateText');
const dateTextBottom = document.getElementById('dateTextBottom');
const monthText = document.getElementById('monthText');
const uncatCount = document.getElementById('uncatCount');
const dayTotal = document.getElementById('dayTotal');
const loadingMsg = document.getElementById('loadingMsg');
const errorMsg = document.getElementById('errorMsg');
const mainTable = document.getElementById('mainTable');
const fallbackNotice = document.getElementById('fallbackNotice');

const firstBtn = document.getElementById('firstBtn');
const prevBtn  = document.getElementById('prevBtn');
const nextBtn  = document.getElementById('nextBtn');
const lastBtn  = document.getElementById('lastBtn');
let usedFallbackData = false;
let fallbackReason = "";

// ----- API Functions -----
function updateFallbackBanner() {
  if (!fallbackNotice) return;
  if (usedFallbackData) {
    if (fallbackReason === "disabled") {
      fallbackNotice.innerHTML = `Showing sample data (live API disabled). Append <code>?use_api=1</code> to the URL to query ${API_BASE}.`;
    } else {
      fallbackNotice.innerHTML = `Connected API at ${API_BASE} is unavailable. Showing sample data instead. <a href="?use_api=1">Retry API</a>`;
    }
    fallbackNotice.style.display = 'block';
  } else {
    fallbackNotice.style.display = 'none';
    fallbackNotice.textContent = '';
  }
}

async function fetchJsonWithFallback(primaryUrl, fallbackUrl) {
  if (!preferApi) {
    fallbackReason = "disabled";
    usedFallbackData = true;
    const fallbackResponse = await fetch(fallbackUrl, { cache: "no-store" });
    if (!fallbackResponse.ok) {
      throw new Error(`Failed to fetch fallback data: ${fallbackResponse.status} ${fallbackResponse.statusText}`);
    }
    return await fallbackResponse.json();
  }
  try {
    const response = await fetch(primaryUrl, { cache: "no-store" });
    if (!response.ok) {
      throw new Error(`Primary request failed: ${response.status} ${response.statusText}`);
    }
    fallbackReason = "";
    return await response.json();
  } catch (primaryError) {
    console.warn('[daily-expense-categorizer] Falling back to static data:', primaryError);
    const fallbackResponse = await fetch(fallbackUrl, { cache: "no-store" });
    if (!fallbackResponse.ok) {
      throw new Error(`Failed to fetch fallback data: ${fallbackResponse.status} ${fallbackResponse.statusText}`);
    }
    usedFallbackData = true;
    fallbackReason = "error";
    return await fallbackResponse.json();
  }
}

async function fetchTransactions() {
  return await fetchJsonWithFallback(
    `${API_BASE}/transactions`,
    './data/transactions.json'
  );
}

async function fetchCategories() {
  const flatCategories = await fetchJsonWithFallback(
    `${API_BASE}/categories`,
    './data/categories.json'
  );

  // Convert flat list to hierarchical structure for category-picker
  // Assuming categories have parent_id field for hierarchy
  return buildCategoryTree(flatCategories);
}

function buildCategoryTree(categories) {
  const map = {};
  const roots = [];

  // First pass: create map and convert to CategoryNode format
  categories.forEach(cat => {
    map[cat.id] = {
      id: String(cat.id),
      label: cat.name,
      children: [],
      _original: cat  // Keep reference to original data
    };
  });

  // Second pass: build tree structure
  categories.forEach(cat => {
    const node = map[cat.id];
    if (cat.parent_id && map[cat.parent_id]) {
      map[cat.parent_id].children.push(node);
    } else {
      roots.push(node);
    }
  });

  // Clean up empty children arrays
  Object.values(map).forEach(node => {
    if (node.children.length === 0) {
      delete node.children;
    }
  });

  return roots;
}

function findCategoryNodeById(nodes, id) {
  for (const node of nodes) {
    if (node.id === id) return node;
    if (node.children) {
      const found = findCategoryNodeById(node.children, id);
      if (found) return found;
    }
  }
  return null;
}

async function updateTransactionCategory(transactionId, categoryId) {
  const response = await fetch(`${API_BASE}/transactions/${transactionId}/category`, {
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ category_id: categoryId })
  });
  if (!response.ok) throw new Error(`Failed to update category: ${response.statusText}`);
  return await response.json();
}

// ----- Data Loading -----
async function loadData() {
  console.log('[DEBUG] loadData() called');
  try {
    console.log('[DEBUG] Starting data load...');
    usedFallbackData = false;
    fallbackReason = "";
    loadingMsg.style.display = 'block';
    errorMsg.style.display = 'none';
    mainTable.style.display = 'none';
    updateFallbackBanner();
    console.log('[DEBUG] UI elements initialized');

    // Load transactions and categories in parallel
    console.log('[DEBUG] Fetching transactions and categories...');
    console.log('[DEBUG] API_BASE:', API_BASE);
    [allTransactions, categoryOptions] = await Promise.all([
      fetchTransactions(),
      fetchCategories()
    ]);

    console.log('[DEBUG] Loaded transactions:', allTransactions.length);
    console.log('[DEBUG] Loaded categories:', categoryOptions.length);
    console.log('[DEBUG] Sample transaction:', allTransactions[0]);

    if (allTransactions.length === 0) {
      errorMsg.textContent = 'No transactions found in database.';
      errorMsg.style.display = 'block';
      loadingMsg.style.display = 'none';
      return;
    }

    // Organize data by date - reference original objects instead of copying
    dataByDate = allTransactions.reduce((acc, t) => {
      (acc[t.date] ||= []).push(t);
      return acc;
    }, {});

    // Get unique months
    months = Array.from(new Set(allTransactions.map(t => monthKey(t.date)))).sort();

    // Dates available per month (sorted)
    datesByMonth = months.reduce((acc, m) => {
      const dates = Object.keys(dataByDate).filter(d => monthKey(d) === m).sort();
      acc[m] = dates;
      return acc;
    }, {});

    // Populate month selector
    monthSelect.innerHTML = '';
    months.forEach(m => {
      const opt = document.createElement('option');
      opt.value = m;
      opt.textContent = monthLabel(m);
      monthSelect.appendChild(opt);
    });

    // Set initial state to most recent month
    state.month = months[months.length - 1];
    state.dayIdx = datesByMonth[state.month].length - 1; // Most recent day
    monthSelect.value = state.month;

    console.log('[DEBUG] Rendering table...');
    loadingMsg.style.display = 'none';
    mainTable.style.display = 'table';
    render();
    updateFallbackBanner();
    console.log('[DEBUG] Render complete!');

  } catch (error) {
    console.error('[DEBUG ERROR] Error loading data:', error);
    console.error('[DEBUG ERROR] Stack:', error.stack);
    errorMsg.textContent = `Error loading data: ${error.message}. Make sure the API server is running at ${API_BASE}`;
    errorMsg.style.display = 'block';
    loadingMsg.style.display = 'none';
  }
}

// Reload just the transactions (keeps current view state)
async function reloadTransactions() {
  try {
    usedFallbackData = false;
    fallbackReason = "";
    updateFallbackBanner();
    // Fetch fresh data from database
    allTransactions = await fetchTransactions();
    updateFallbackBanner();

    // Rebuild dataByDate with fresh data
    dataByDate = allTransactions.reduce((acc, t) => {
      (acc[t.date] ||= []).push(t);
      return acc;
    }, {});

    // Re-render current view
    render();
  } catch (error) {
    console.error('Error reloading transactions:', error);
    alert('Failed to reload data: ' + error.message);
  }
}

// ----- Rendering -----
function currentDate(){
  const dates = datesByMonth[state.month];
  return dates[state.dayIdx];
}

function render(){
  const d = currentDate();
  const items = dataByDate[d] || [];

  // Update meta
  monthText.textContent = monthLabel(state.month);
  dateText.textContent = d;
  dateTextBottom.textContent = d;

  // Build rows
  rowsEl.innerHTML = '';
  let uncat = 0;
  let total = 0;

  for(const item of items){
    total += (item.amount || 0);
    const tr = document.createElement('tr');
    if(item.category) tr.classList.add('categorized');

    // Vendor/Desc
    const tdVendor = document.createElement('td');
    tdVendor.innerHTML = `<strong>${item.vendor || 'Unknown'}</strong><br><span class="status">${item.method || ''}</span>`;
    tr.appendChild(tdVendor);

    // Amount
    const tdAmt = document.createElement('td');
    tdAmt.textContent = fmtCurrency(item.amount || 0);
    tr.appendChild(tdAmt);

    // Category
    const tdCat = document.createElement('td');
    tdCat.className = 'category';

    // Always create category-picker component
    const picker = document.createElement('category-picker');
    picker.setAttribute('expense-id', item.id);
    picker.setAttribute('placeholder', 'Select category…');

    // Create inline JSON taxonomy from categoryOptions
    const script = document.createElement('script');
    script.type = 'application/json';
    script.textContent = JSON.stringify(categoryOptions);
    picker.appendChild(script);

    // Always append picker to DOM first
    tdCat.appendChild(picker);

    // If already categorized, set the value (will show in green completed state)
    if(item.category){
      // Wait for component to fully initialize and load taxonomy
      const checkReady = () => {
        const select = picker.shadowRoot?.querySelector('select');
        if (select && select.options.length > 1) {
          // Component is ready - options are loaded
          console.log('Setting picker value for transaction', item.id, ':', item.category);
          picker.value = item.category;
          console.log('Picker state after setting:', picker.getAttribute('data-state'));
        } else {
          // Not ready yet, check again
          setTimeout(checkReady, 50);
        }
      };
      setTimeout(checkReady, 0);
    } else {
      uncat++;
    }

    // Listen for categorization completion
    picker.addEventListener('completed', async (e) => {
      try {
        const fullLabel = e.detail.label;
        const path = e.detail.path; // Array of category labels

        // Find the category by traversing the path in the tree
        let categoryNode = null;
        let currentNodes = categoryOptions;

        for (const label of path) {
          const node = currentNodes.find(n => n.label === label);
          if (!node) break;
          categoryNode = node;
          currentNodes = node.children || [];
        }

        if (categoryNode && categoryNode._original) {
          await updateTransactionCategory(item.id, categoryNode._original.id);

          // Reload data from database to get updated categories
          await reloadTransactions();
        } else {
          console.error('Could not find category for path:', path);
        }
      } catch (error) {
        console.error('Error updating category:', error);
        alert('Failed to update category: ' + error.message);
      }
    });

    // Listen for reset button click to clear category in database
    picker.addEventListener('reset', async (e) => {
      try {
        await updateTransactionCategory(item.id, null);

        // Reload data from database to get updated categories
        await reloadTransactions();
      } catch (error) {
        console.error('Error resetting category:', error);
        alert('Failed to reset category: ' + error.message);
      }
    });

    tr.appendChild(tdCat);

    // Notes
    const tdNotes = document.createElement('td');
    const input = document.createElement('input');
    input.type = 'text';
    input.value = item.notes || '';
    input.placeholder = 'Add a note (optional)';
    input.addEventListener('input', () => item.notes = input.value);
    tdNotes.appendChild(input);
    tr.appendChild(tdNotes);

    // Status
    const tdStatus = document.createElement('td');
    tdStatus.className = 'status';
    tdStatus.textContent = item.category ? 'Categorized' : 'Needs category';
    tr.appendChild(tdStatus);

    rowsEl.appendChild(tr);
  }

  uncatCount.textContent = uncat;
  dayTotal.textContent = fmtCurrency(total);

  // Update nav button states
  const lastIndex = datesByMonth[state.month].length - 1;
  firstBtn.disabled = state.dayIdx <= 0;
  prevBtn.disabled  = state.dayIdx <= 0;
  nextBtn.disabled  = state.dayIdx >= lastIndex;
  lastBtn.disabled  = state.dayIdx >= lastIndex;
}

// ----- Events -----
monthSelect.addEventListener('change', () => {
  state.month = monthSelect.value;
  state.dayIdx = 0; // jump to first available day in that month
  render();
});

firstBtn.addEventListener('click', () => { state.dayIdx = 0; render(); });
lastBtn .addEventListener('click',  () => { state.dayIdx = datesByMonth[state.month].length - 1; render(); });
prevBtn .addEventListener('click', () => { if(state.dayIdx > 0) state.dayIdx--; render(); });
nextBtn .addEventListener('click', () => { const max = datesByMonth[state.month].length - 1; if(state.dayIdx < max) state.dayIdx++; render(); });

// Keyboard shortcuts (← →)
document.addEventListener('keydown', (e) => {
  if(e.key === 'ArrowLeft') prevBtn.click();
  if(e.key === 'ArrowRight') nextBtn.click();
});

// Initial load
console.log('[DEBUG] Calling loadData()...');
loadData().catch(err => {
  console.error('[DEBUG] Unhandled error in loadData:', err);
});
</script>
</body>
</html>
